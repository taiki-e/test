use std::{
    panic::Location,
    path::{Path, PathBuf},
};

use anyhow::Result;
use fs_err as fs;
use serde::Serialize;

pub fn root_dir() -> PathBuf {
    let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    dir.pop(); // codegen
    dir.pop(); // tools
    dir
}

#[track_caller]
pub fn header(comment_token: &str, include_caller_location: bool) -> String {
    let mut out =
        format!("{} This file is @generated by {}.\n", comment_token, env!("CARGO_BIN_NAME"));
    out += &format!("{} It is not intended for manual editing.\n", comment_token);
    if include_caller_location {
        out += &format!("{}\n", comment_token);
        out += &format!("{} See {} for details.\n", comment_token, Location::caller().file());
    }
    out += "\n";
    out
}

// #[track_caller]
// pub fn write(path: impl AsRef<Path>, content: impl ToString) -> Result<()> {
//     fs::write(path.as_ref(), header("//", true) + &content.to_string())?;
//     let status = Command::new("rustfmt")
//         .arg(path.as_ref())
//         .args(&["--config", "normalize_doc_attributes=true,format_macro_matchers=true"])
//         .status()?;
//     if !status.success() {
//         bail!("rustfmt didn't exit successfully");
//     }
//     Ok(())
// }

pub fn write_json(path: impl AsRef<Path>, value: &impl Serialize) -> Result<()> {
    let mut buf = serde_json::to_vec_pretty(value)?;
    buf.push(b'\n'); // insert_final_newline
    fs::write(path, buf)?;
    Ok(())
}
